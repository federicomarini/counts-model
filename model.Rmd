# Counts modeling {#model}

In this section, I will discuss the statistical models that are
often used to analyze RNA-seq data, in particular gene-level count
matrices. I will then use the *DESeq2* package to calculate
scaling factors, estimate biological dispersion within groups of
samples, and perform differential testing per gene [@Love2014].

Some other popular Bioconductor packages for RNA-seq analysis include the 
*edgeR* package [@Robinson2010,@McCarthy2012] and the *limma-voom*
method in the *limma* package [@Law2014]. The approach taken by
*DESeq2* for estimation of dispersion is similar to the method
proposed by @Wu2012 in the *DSS* Bioconductor package.

I will begin by investigating the estimated counts that were imported
from the *Salmon* software, and comparing these counts across and
within samples. I will note the varying precision that the counts
offer for log ratio comparisons between samples. Finally, I will
perform per-gene testing for differential expression using the
*DESeq2* package, and multiple test correction, including the *IHW*
method [@Ignatiadis2016].

First, it's useful to explore the varying number of fragments (pairs
of reads) that have been assigned to the genes for each sample. For a
typical mammalian RNA-seq experiment, we might expect tens of millions
of fragments per sample, which are distributed across tens of
thousands of genes, although there is inevitably a range of sequencing
depth for each sample:

```{r colsums}
assayNames(gse)
cs <- colSums(assay(gse, "counts"))
hist(cs/1e6, col="grey", border="white")
```

Let us first consider just two samples, one from OCT4 untreated group
and one from the OCT4 treated group. I will make a plot examining the
proportion of the total count for each gene. I will first subset to
only those genes where both samples have a count of 5 or more, to cut
down on the number of points to plot. Here I use the total count,
`colSums(cts)` to divide the counts for each sample, while later we
will discuss a robust estimator for sequencing depth variation across
samples.

Before I create the proportions, it's important to remember that,
because genes with longer transcripts will produce more cDNA
fragments, the proportion estimated here (without taking into account
the length of the feature) does not estimate the proportion of
*molecules*. The `abundance` assay of the `gse` object contains
estimates of the molecules, in transcripts per million (TPM). For more
on how these estimates are computed, consult the *Salmon* methods
paper [@Patro2017].

```{r make-prob}
colData(gse)
cts <- assay(gse, "counts")[,c(1,4)]
idx <- rowSums(cts >= 5) == 2
cts <- cts[idx,]
p <- sweep(cts, 2, colSums(cts), "/")
```

We can examine the ratio of the proportions for each gene, over the
geometric mean, using the `maplot` function from the *rafalib*
package. We will plot the ratio and the geometric mean of proportions
both on the log scale. `maplot` is a basic function for making an
"MA-plot" which has been used in transcriptomics since at least the
early 2000s when it was used for microarray datasets [@Dudoit2002;
@Roberts2000]. Later I will show a specialized MA-plot function for
RNA-seq data in *DESeq2*.

```{r maplot}
library(rafalib)
maplot(log10(p[,1]), log10(p[,2]), n=nrow(p), 
       cex=.3, col=rgb(0,0,0,.2))
abline(h=0, col=rgb(0,0,1,.5))
```

The red line is a smooth curve through the log ratios 
(here $\log_{10}$, although we will later switch to $\log_2$ for the
ratios). Note that the line is relatively flat across many orders of
magnitude of the proportion. So whether the gene has 1 millionth of
the total count (-6) or up to one thousandth of the total count (-3),
the ratio between the two samples tends to fluctuate around 0, with
most of the points somewhere between -0.1 and 0.1. The points further
off the horizontal line may indicate differentially expressed genes,
but we will better identify these using all of the replicates.

While just considering the two samples, I can also examine the
histogram of the x-axis above, the mean of the $\log_{10}$ proportions
(or equivalently the $\log_{10}$ of the geometric mean of
proportions). We see that most genes that we are considering fall in
the range from 1/10,000,000 (-7) to 1/10,000 (-4) of the total
count. That these ratios are very low is relevant for the choice of
statistical distribution.

```{r mean-prob}
mean.log.p <- rowMeans(log10(p))
hist(mean.log.p,  col="grey", border="white")
```

```{r maplot2}
library(rafalib)
maplot(log10(p[,1]), log10(p[,2]), n=nrow(p),
       xlim=c(-6.5, -3.5), ylim=c(-2,2),
       cex=.3, col=rgb(0,0,0,.2))
abline(h=0, col=rgb(0,0,1,.5))
```

I will zoom out on the y-axis and zoom in on the x-axis on the MA-plot
to emphasize that for the range where most of the genes are, there is
actually not much variation in the ratio of proportions across the
treatment. 

$10$ is not a great base for the logarithm, because it's extreme to
have a 10 fold change, and then it becomes hard to interpret the
meaningful changes in the range from 0 to 1. Much better is to use
$\log_2$, as we can easily interpret 1 as doubling, 2 as quadrupling,
etc. Now I calculate the $\log_2$ ratio of proportions and plot the
histogram of these log ratios, when the log10 mean proportion is
between -6 and -4:

```{r lfc-hist}
lfc <- log2(p[,2]) - log2(p[,1])
hist(lfc[between(mean.log.p, -6, -4)], 
     breaks=seq(-10,10,by=.1),
     xlim=c(-5,5),
     col="grey50", border="white")
```

Again we see that it's rare for there to be an extreme change (more
than doubling) comparing these two samples from different treatment
groups. Most of the genes fall around 0. Exactly 0 implies no change
in the proportion as calculated using the total count.

Before we begin modeling the counts from the RNA-seq experiment, I
produce one more plot to give a sense of expected sampling variation
with counts of a similar distribution to the ones we
observed. Supposing that the proportions `p` was fixed for the first
sample, and we draw 30,000,000 fragments, we will obtain a multinomial
distribution. When the number of observations is large, and the
proportions are small, the count for any given gene is well
approximated by a Poisson distribution. So I will create two simulated
technical replicate samples, by creating two draws from a Poisson
distribution along the genes. I think repeat the same code as above,
to examine the MA-plot for the simulated counts.

```{r sim-maplot}
sim.cts <- matrix(rpois(nrow(p) * 2, 30e6 * p[,1]), ncol=2)
colSums(sim.cts)
idx <- rowSums(sim.cts >= 5) == 2
sim.cts <- sim.cts[idx,]
sim.p <- sweep(sim.cts, 2, colSums(sim.cts), "/")
maplot(log10(sim.p[,1]), log10(sim.p[,2]), n=nrow(p), 
       cex=.3, col=rgb(0,0,0,.2))
abline(h=0, col=rgb(0,0,1,.5))
```

Note that, even after filtering out genes that do not have a count of
5 or more for both samples, there is still substantial inflation of
the ratio of proportions for the small count genes.

```{r make-dds}
library(DESeq2)
dds <- DESeqDataSet(gse, ~line + line:condition)
keep <- rowSums(counts(dds) >= 10) >= 3
table(keep)
dds <- dds[keep,]
```

```{r deseq, cache=TRUE}
dds <- DESeq(dds)
```

```{r disp-ests}
plotDispEsts(dds, ylim=c(1e-3, .5), xlim=c(5,1e5))
```

```{r pca}
vsd <- vst(dds, blind=FALSE)
plotPCA(vsd, intgroup=c("line","condition"))
```

```{r results}
resultsNames(dds)
res <- results(dds, name="lineOCT4.conditiontrt")
summary(res)
```

```{r apeglm, cache=TRUE}
library(apeglm)
lfc <- lfcShrink(dds, coef="lineOCT4.conditiontrt", type="apeglm")
```


```{r ma-shrink}
plotMA(res, ylim=c(-4,4), 
       colNonSig="grey60", colSig="blue", colLine="grey40")
```

```{r ma-shrinkn2}
plotMA(lfc, ylim=c(-4,4), 
       colNonSig="grey60", colSig="blue", colLine="grey40")
```


```{r symbols}
lfc$SYMBOL <- mcols(dds)$SYMBOL
tab <- lfc %>% as.data.frame %>%
        filter(between(baseMean, 1e4, 1e5), 
               between(abs(log2FoldChange), 1, 4))
tab <- tab[complete.cases(tab),]
```

```{r ma-symbols}
plotMA(lfc, ylim=c(-4,4),
       colNonSig="grey60", colSig="blue", colLine="grey40")
with(tab, {
        points(baseMean, log2FoldChange, cex=2, col="blue")
        text(baseMean, log2FoldChange, SYMBOL, pos=4, col="blue")
})
```

```{r signif}
dat <- as.data.frame(lfc)
dat <- dat[complete.cases(dat),]
dat <- dat %>% mutate(sig = ifelse(padj < .1, "Y", "N"))
tab$sig <- "Y"
```

```{r ma-repel}
library(ggplot2)
library(ggrepel)
ggplot(dat, aes(baseMean, log2FoldChange, col=sig, label=SYMBOL)) + 
        geom_point() + scale_x_log10() + 
        geom_hline(yintercept=0, col="grey40") + 
        scale_color_manual(values=c("grey60", "blue")) +
        geom_point(data=tab, shape=1, size=5, show.legend=FALSE) + 
        geom_label_repel(data=tab,
                         nudge_x = 1,
                         nudge_y = 2* sign(tab$log2FoldChange),
                         show.legend=FALSE)
```

```{r ihw, cache=TRUE}
library(IHW)
res.ihw <- results(dds, name="lineOCT4.conditiontrt", filterFun=ihw)
summary(res.ihw)
```

```{r ihw-obj}
ihw.obj <- metadata(res.ihw)$ihwResult
plot(ihw.obj)
```

```{r compare-fdr}
table(res$padj < .05, IHW=res.ihw$padj < .05)
```
